# MetaSearchEngineDemo
MetaSearchEngineDemoWithJava

```
概述
聚合搜索初步定义为个性化“元搜索”，同时将信息聚合在一起实现网络工具化、个性化的发展需求；提升网络使用效率，让用户更快
地从繁复的搜索系统里解放出来，让上网搜索更轻松有效。本程序针对常用的Google、Baidu、Bing等搜索引擎进行了聚合其搜索结果
的实践，实现了元搜索最低要求。聚合的搜索结果将以网页的形式展示出来，并且实现其中的链接可用性。

一、完成一个聚合搜索引擎的基本步骤
1.  获取Google、Baidu、Bing等搜索引擎进行网页搜索时的查询URL模式。
2.  分析各家搜索引擎返回的搜索结果的模式，每个结果定义为一个有效的Item对象。
3.  对提取到所有Item对象进行去重重排序聚合。
4.  回写聚合结果文件，调用浏览器打开。
二、各步的具体操作及其说明
1.获取Google、Baidu、Bing等搜索引擎进行网页搜索时的查询URL模式。
通过在各家搜索引擎提供搜索服务的检索框里输入查询的字串，点击查询后，查看浏览器中的地址栏中的URL模式，即可获得各家搜索引擎
的查询URL模式。以下是以“5sing”为查询关键字获取到的几家主流搜索引擎的查询URL模式。
Google
http://www.google.com.hk/search?q=5sing
Baidu
http://www.baidu.com/s?wd=5sing
Bing
http://hk.bing.com/search?q=5sing
Yahoo
http://www.yahoo.cn/s?q=5sing
2．分析各家搜索引擎返回的搜索结果的模式，每个结果定义为一个有效的Item对象。
通过第1步获得的查询URL，可以通过编程获取到各家搜索引擎对相应查询关键字返回结果。返回的结果以HTTP协议为标准。想要从返回
的结果中提取出有效的结果，需要使用正则表达式过滤其中的无效部分，并将获取到的每一个结果都封装为一个Item对象。通过分析获
得各家搜索引擎返回结果中有效的Item模式（正则表达式):
     Google 
     <li class=\"g\"><h3 class=\"r\">.+?</li>
     Baidu 
     <table.+?><tr><td.+?><h3.+?>.+?</div></td></tr></table>
     Bing
     <li class=\"sa_wr.+?\">.+?</div></div></li>
     Yahoo
     <li class=\"record.+?\">.+?<h3 class=\"title\">.+?</li>
通过以上的正则表达式即可将对应搜索引擎返回的查询结果中的有效条目提取出来，并将每一个条目都封装为一个Item对象。Item对象
保存了该条目的几个重要属性，如下： • Engine  — 该条目来自与那个搜索引擎
• Content — 该条目在搜索引擎中的内容信息，包括相应的布局和格式
• keyString — 该条目在出去了HTML布局和格式之后剩下的关键信息
• Sequence — 该条目在搜索引擎中返回结果中的排序，编号从0开始
• Score  — 该条目在搜索引擎中得分，所有Item初始化为同一个值1.2
  
3. 对提取到所有Item对象进行去重重排序聚合。
  在从各家搜索引擎提取到所有的Item之后，因为各家搜索引擎中返回的Item中存在不好重复的内容，所以首先需要对所有的Item进行
  相似性检测，并将相似性很高的Item以某种方式删除，并保留其中一个的Item，这个过程称为Item去重过程。在进行Item去重的时，
  同时也要对Item的score值进行操作，为去重之后的重排序工作做好准备。
  3.1相似性检测
   在定义两个Item是否相似时，使用Item的keyString属性进行字符串相似性检测。检测算法的基本思想如下。
   两个字符串A和B，假设B是字符串长度较短的一个，B的长度为k。定义一个count变量来记录B的所有子串在A中出现后积累获得相似性
   权重。出现将字符串B的字符串值分段截取出来，并保持截取的字符串在B中的顺序不变，截取的模式为C = subString( i , j ) ，
   其中 0 <= i  < k , i <= j < k。
   获得C之后检测A是否包含C,若包含C,则count值加(j – i).当B的所有子串都检测完毕后,将count值与B的所有字串数想除，得到
                                           rate = count / ( (k + 1) * k /2)，
  rate即为B与A的相似性的度量。根据经验来看，当rate值大于2.7时，说明B与A相似度很高，在聚合的时候应该删除其中一个，并
  且为了保留更多的信息，这里选择删除B，而保留A。
3.2 重新为Item的score属性赋值
在删除B的同时，必须意识到能够删除B，说明A和B所指向的信息不同搜索引擎都检测到了，暗示删除B之后，A信息的score值需要提升，
而非保持初始化值。在对score重新复制时，同时也必须考虑该Item在搜索引擎返回结果中排名，即sequence所记录的信息。基于此，
定义了score新值的计算方式。
   Score = A.score * (A所属引擎返回的Item总数 — A.sequence) / (A.sequence + 1) + 
           B.score * (B所属引擎返回的Item总数 — B.sequence) / (B.sequence + 1).
新得到的score值将作为回写result时排序的第一依据，score值越大，则排名越靠前。若score相同，则再查看sequence属性，sequence
越小，排名越靠前；若score和sequence都相同，则比较keyString的长度，长度越长，信息量越大，排名越靠前。
4. 回写结果文件，调用浏览器打开查看
以“5sing”为查询关键字为例，程序运行结果截图如下：
```
>![这里写图片描述](http://img.blog.csdn.net/20160303224004172)
```
三、不足
在具体实现时只使用了Baidu和Bing两家搜索引擎；
聚合算法没有进行跟大规模的数据验证，使用经验规则来判定的聚合结果显得略有粗糙；
使用JavaSE平台编程，没有充分利用JavaEE平台上对网页处理更为友好资源。
```
参考文献
>1. 美 Cormen, T.H等著；殷建平等译 《算法导论（原书第3版）》 北京：机械工业出版社
>2. 罗刚 著 《自己动手写网络爬虫》 北京：清华大学出版社

